name: CI Pipeline - Build, Testes antes de realizar um merge em um PULL REQUEST para a branch Main, com Deploy e Release Automático em seguida.

# Declaração de variáveis de ambiente da pipeline que não possuem dados sensíveis
env:

  # Retorna o sistema operacional do runner (máquina virtual) que está executando o job.
  OS_VM: ${{ runner.os }}-node-
  
  # Retorna o cálculo do hash SHA-256 dos arquivos críticos do projeto (está sendo usado para gerar chaves de cache definindo como parâmetro arquivos que dão as definições e 
  # as dependências do projeto, para que elas sejam constantemente atualizadas corrretamente e que o build seja rápido, pois está sendo dado como informação arquivos 
  # que contém principalmente as informações sobre as dependências do projeto que podem influenciar a criação ou não do cache).
  KEY_CACHE: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json', '**/package.json', '**/vitest.config.ts', '**/vite.config.ts', '**/tsconfig.vitest.json', '**/tsconfig.node.json', '**/tsconfig.json', '**/tsconfig.app.json', '**/env.d.ts', '**/.eslintrc.cjs', '**/src/main.ts', '**/jest.config.js', '**/src/router/index.ts') }}

  # Retorna o cálculo do hash SHA-256 dos arquivos especificados (nesse caso, só pastas com informações de dependências, que são aquelas que há um desejo 
  # de fazer a recuperação das keys de cache com o parâmetro 'restore-keys', fazendo com que o GitHub Actions encontre um cache correspondente se a chave 
  # principal não tiver um hit exato. Útil para evitar rebuilds completos quando mudanças menores são feitas, melhorando o desempenho da pipeline em geral.
  RESTORE_KEYS: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json', '**/package.json') }}

  # Retorna o token de acesso automático, o que permite que 'actions' interajam com o repositório Github em nome do Github Actions.
  # Está sendo usado para autenticação em várias 'actions' envolvidas na pipeline que faz processos de escrita/mudança, como ao realizar deploy ou gerar uma nova release.
  # É a única variável usada que representa um dado sensível, sendo configurado dentro da ferramenta do Github chamada 'secrets', mantendo a integridade dos processos.
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


# Instrução inicial: em que momentos o workflow deve ser rodado, no caso são em PR e pushs realizados diretamente na branch 'main'
on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]


# Descrição de jobs de build, testes e uso de cache para otimizar o processamento da pipeline
jobs:
  
  build-and-test-with-cache:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v4.0.2
        with:
          node-version: '20'
          cache: 'npm'
      - name: Cache node modules
        uses: actions/cache@v4.0.2
        with:
          path: node_modules
          key: ${{ env.KEY_CACHE }}
          restore-keys: |
            ${{ env.RESTORE_KEYS }}
            ${{ env.OS_VM }}
          upload-chunk-size: 262144  # em bytes (250 MB), tamanho de chunk ideal para processamento paralelo ou assíncrono, podendo aumentar o desempenho da pipeline
      - name: Install dependencies
        run: npm install
      - name: Run build
        run: npm run build
      - name: Run tests
        run: npm run test

  # Job para realizar o auto-merge caso o PR ou push passe pela build e pelos testes
  auto-merge:
    needs: build-and-test-with-cache
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0 
      - name: Automerge
        uses: pascalgn/automerge-action@v0.14.3
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MERGE_LABELS: ""  
          MERGE_METHOD: "squash"  
          MERGE_COMMIT_MESSAGE: "pull-request-description"
          MERGE_RETRIES: "6"  
          MERGE_RETRY_SLEEP: "10000"  

  # Pushs diretamente na branch 'main' só ocorrem em nosso processo através das actions de automação dessa cadeia de CI. Seja para commitar um release, um deploy, um metadado, ou até um issue.
  # Logo, toda nova feature é desenvoldida em branches separadas e vão para a 'main' quando já estão finalizadas através de Pull Request.
  # Dessa forma, PR's geram deploys e releases, enquanto que push direto na branch não participa do produto, mas sim ao processo de desenvolvimento com Devops. 
  # Não havendo benefício ao cliente, essa parte automatizada será evitada diante das circunstâncias citadas.
  push-changes-of-version:
    needs: [build-and-test-with-cache, auto-merge]
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true && github.base_ref == 'main'
    steps:
        - name: Bump version and push tag
          id: tag_version
          uses: anothrNick/github-tag-action@1.26.0
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            DEFAULT_BUMP: patch
         # Action que executa script js que atualiza o valor de 'version' nos arquivos package.json e package-lock.json, responsáveis pela informações sobre o projeto e dependências. 
         # Passo importante para a rastreabilidade e transparência com os usuários da versão que estão utilizando do projeto.
        - name: Update package.json and package-lock.json
          run: node update-version.js ${{ steps.tag_version.outputs.new_tag }}
        - name: Commit updated version files
          run: |
                git config --local user.email "action@github.com"
                git config --local user.name "GitHub Action"
                git add package.json package-lock.json
                git commit -m "Update version to ${{ steps.tag_version.outputs.new_tag }}"
                git push

              
  # Descrição da etapa de deploy automático a partir de um merge na branch 'main', 
  # acionando a condição de gerar um novo deploy no Github Pages da versão mais atualizada do projeto, 
  # considerando que cada PR é uma feature nova.
  deploy:
    needs: [build-and-test-with-cache, auto-merge, push-changes-of-version]
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true && github.base_ref == 'main'
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v4.0.2
        with:
          node-version: '20'
      - name: Build
        run: npm run build
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ env.GITHUB_TOKEN }}
          publish_dir: ./dist


# Descrição da etapa de lançar uma nova release, assim que ocorrer um merge de um PR na branch 'main', mapeando a release pelo SHA do commit/pull request
  release:
    needs: deploy
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true && github.base_ref == 'main'
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v4.0.2
        with:
          node-version: '20'
      - name: Create Release
        uses: actions/create-release@v1
        with:
          # Variável que contém o SHA do commit/pull request atual que está sendo testado ou que disparou o workflow.
          # Está sendo usado para taggear builds e releases oara referenciar exatamente qual código foi construído ou lançado.
          # Usar o SHA do commit garante unicidade e rastreabilidade direta para o estado exato do código naquele commit. É útil em ambientes de CI onde cada commit pode gerar uma nova build.
          # No entanto, pode não ser ideal para comunicação com usuários finais ou quando se quer manter um histórico claro de versões do software. Portanto será usado para dar o nome da tag, 
          # enquanto que o nome "comercial" da release receberá outra lógica de padrão de nomeação.
          tag_name: ${{ github.sha }}
          # Padrão de Nomeação de Versão "semântico", no formato "X.X.X", automatizado com o uso de actions.
          release_name: Release ${{ steps.tag_version.outputs.new_tag }}
          # Permite revisões manuais e ajustes antes da publicação, dando tempo para preparar ou aprimorar os release notes e outros documentos ou artefatos de release,
          # além de testes em ambientes controlados antes do lançamento público. Uma das nossas estratégias no projeto é um 'code review' antes da publicação final, logo o parâmetro recebe valor verdadeiro.
          draft: true
          # Especifica se a release deve ser marcada como uma pré-release, sugerindo que não é totalmente estável e é destinada para testes ou uso antecipado correndo riscos com novas features.
          # Pode ser útil para feedbacks antecipados do cliente, mas por padrão a gente assume que a versão é estável, já que se busca uma cobertura de código próxima do 100% a todo momento, inserindo novas
          # validações com testes de unidade ou de integração assim que novas features com novos blocos de código são inseridos, antes da realização do PR para a branch 'main', garantindo a integridade da regra de negócio.
          # Logo, o parâmetro recebe por padrão o valor de falso, mas pode ser alterado a depender de certas circunstâncias pontuais (Feedback antecipado ou redução de riscos).
          prerelease: false
