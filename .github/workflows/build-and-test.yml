name: CI Pipeline - Build and Test

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:

  build-and-test-with-cache:
    runs-on: ubuntu-latest

    steps:
    
      - name: Set up cache variables
        id: cache-vars
        run: |
          echo "OS_VM=${{ runner.os }}-node-" >> $GITHUB_ENV
          echo "KEY_CACHE=${{ runner.os }}-node-${{ hashFiles('**/package-lock.json', '**/package.json', '**/vitest.config.ts', '**/vite.config.ts', '**/tsconfig.vitest.json', '**/tsconfig.node.json', '**/tsconfig.json', '**/tsconfig.app.json', '**/env.d.ts', '**/.eslintrc.cjs', '**/src/main.ts', '**/jest.config.js', '**/src/router/index.ts') }}" >> $GITHUB_ENV
          echo "RESTORE_KEYS=${{ runner.os }}-node-${{ hashFiles('**/package-lock.json', '**/package.json') }}" >> $GITHUB_ENV

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Setup Node Environment
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Cache node modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ env.KEY_CACHE }}
          restore-keys: |
            ${{ env.RESTORE_KEYS }}
            ${{ env.OS_VM }}
          upload-chunk-size: 262144

      - name: Install dependencies
        run: npm install

      - name: Run build
        run: npm run build

      - name: Run unit tests and coverage tool
        run: npm run test --coverage

      - name: Execute sonar-scanner in the project and save to SonarCloud
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          npm install -g sonar-scanner
          sonar-scanner

  push-changes-of-version:
    needs: [build-and-test-with-cache]
    runs-on: ubuntu-latest

    steps:
    
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Set up /github/workspace as a safe directory
        run: git config --global --add safe.directory /github/workspace

      - name: Check out to the main branch
        run: |
          git fetch origin
          git checkout main

      - name: Check for new commits
        id: check_commits
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          if [ "$LAST_TAG" = "0.0.0" ]; then
            echo "No previous tags found."
            echo "new_commits=true" >> $GITHUB_ENV
          else
            NEW_COMMITS=$(git log $LAST_TAG..HEAD --oneline)
            if [ -z "$NEW_COMMITS" ]; then
              echo "No new commits since the last tag."
              echo "new_commits=false" >> $GITHUB_ENV
            else
              echo "New commits found."
              echo "new_commits=true" >> $GITHUB_ENV
            fi
          fi

      - name: Bump version and push tag
        id: tag_version
        if: env.new_commits == 'true'
        run: |
          git config --global --add safe.directory /github/workspace
          DEFAULT_BUMP="patch"
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          if [ "$LAST_TAG" = "0.0.0" ]; then
            NEW_TAG="0.0.1"
          else
            IFS='.' read -r -a TAG_PARTS <<< "$LAST_TAG"
            MAJOR=${TAG_PARTS[0]}
            MINOR=${TAG_PARTS[1]}
            PATCH=${TAG_PARTS[2]}
            PATCH=$((PATCH + 1))
            NEW_TAG="$MAJOR.$MINOR.$PATCH"
          fi
          echo "new_tag=$NEW_TAG" >> $GITHUB_ENV
          echo "::set-output name=new_tag::$NEW_TAG"

      - name: Check new tag output
        if: env.new_commits == 'true'
        run: echo "New tag is ${{ steps.tag_version.outputs.new_tag }}"

      - name: Verify update-version.cjs existence
        if: env.new_commits == 'true'
        run: |
          if [ ! -f update-version.cjs ]; then
            echo "update-version.cjs not found!"
            ls -al
            exit 1
          fi

      - name: Update package.json and package-lock.json
        if: env.new_commits == 'true'
        run: node update-version.cjs ${{ steps.tag_version.outputs.new_tag }}

      - name: Show updated files
        if: env.new_commits == 'true'
        run: |
          echo "Contents of package.json:"
          cat package.json
          echo "Contents of package-lock.json:"
          cat package-lock.json

      - name: Commit updated version files
        if: env.new_commits == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json package-lock.json
          git commit -m "Update version to ${{ steps.tag_version.outputs.new_tag }}"

      - name: Wait for status check of build-and-test-with-cache (branch rule)
        if: env.new_commits == 'true'
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { context, github } = require('@actions/github');
            const ref = context.ref;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const checkRunsResponse = await github.rest.checks.listForRef({
              owner,
              repo,
              ref,
            });

            const statusChecks = checkRunsResponse.data.check_runs.filter(
              (check) => check.name === 'build-and-test-with-cache'
            );

            if (statusChecks.length === 0) {
              throw new Error('Required status check "build-and-test-with-cache" not found.');

            const statusCheck = statusChecks[0];

            if (statusCheck.conclusion !== 'success') {
              throw new Error(`Status check "build-and-test-with-cache" has not passed. Conclusion: ${statusCheck.conclusion}`);
            }

      - name: Push changes
        if: env.new_commits == 'true'
        run: |
          git push origin main
